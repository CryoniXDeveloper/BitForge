RAM Addressing and Memory Access Explained

When working with RAM, it is crucial to understand absolute and relative addressing, how to calculate boundaries, and how to safely perform multi-byte writes.

Understanding RAM Addresses

Consider an example:
RAM_START = 0x20000000 (first valid absolute address)
RAM_SIZE = 256 bytes

If we naively add the RAM size to the start address:
RAM_START + RAM_SIZE = 0x20000000 + 0x100 = 0x20000100

This calculation overshoots the last valid address, because 0x20000000 is already the first valid byte.

To correctly calculate the last valid address:
RAM_END = RAM_START + RAM_SIZE - 1

Example:
RAM_END = 0x20000000 + 0x100 - 1 = 0x200000FF

Valid absolute addresses: 0x20000000 … 0x200000FF
This ensures we do not write beyond the allocated memory region.

Absolute vs Relative Addressing

CPU/board sees absolute addresses. RAM sees relative addresses to its start:
address_relative = address_absolute - RAM_START

Example:
address_absolute = 0x20000024
address_relative = 0x20000024 - 0x20000000 = 0x24
memory[0x24] = 0x19

RAM only uses relative addresses internally. Always provide absolute addresses to RAM and convert internally. Do not send already-relative addresses and subtract again — this will cause errors.

Multi-byte Writes

When writing multiple bytes (16-bit, 32-bit, 64-bit, or vectors), each byte must be written sequentially to avoid overwriting:
memory[address_relative + i] = byte[i]

Boundary checks must account for length:
if (address_relative + length - 1 > RAM_SIZE - 1) { error("Attempt to write beyond allocated RAM"); }

This ensures that writing multiple bytes at the end of RAM does not overflow into unallocated memory.

Unsigned 64-bit Addresses

Using uint64_t for addresses provides maximum range and prevents negative values.

Example wrap-around behavior:
uint64_t value = 0 - 1; // results in 18446744073709551615

Why not 18446744073709551616?
64 bits can store values 0 … 2^64 - 1
2^64 = 18446744073709551616 would require 65 bits → wraps to 0
Binary perspective: 18446744073709551615 = 111111…1111 (64 ones), the maximum unsigned 64-bit value

This wrap-around is normal in unsigned arithmetic and must be understood when performing pointer arithmetic or calculating memory offsets.

Key Principles

Inclusive address ranges: Last valid RAM address = RAM_START + RAM_SIZE - 1

Absolute addresses: Always provide absolute addresses to RAM; convert to relative internally

Boundary checks: For multi-byte writes, check that address_relative + length - 1 <= RAM_SIZE - 1

Use uint64_t: Ensures safety, avoids negative addresses, and maximizes range

Relative addressing in RAM: Treat the first byte of RAM as index 0 internally; never double-subtract RAM_START

Practical Example

Writing a single byte:
write8(0x20000024, 0x19);
RAM converts internally: memory[0x24] = 0x19

Writing 2 bytes near the end:
write16(0x200000FE, 0xABCD);
Boundary check fails if it exceeds RAM_END

This approach guarantees safe, consistent, and scalable memory operations for writing 8, 16, 32, 64, or larger data types, while keeping a clear distinction between absolute and relative addressing.